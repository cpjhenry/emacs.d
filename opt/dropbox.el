;;; dropbox.el --- Emacs backend for dropbox -*- lexical-binding: t -*-

;; Copyright (C) 2022 lorniu <lorniu@gmail.com>

;; Author: lorniu <lorniu@gmail.com>
;; URL: https://github.com/lorniu/emacs-dropbox
;; Package-Requires: ((emacs "27.1"))
;; Keywords: tools
;; SPDX-License-Identifier: MIT
;; Version: 1.0

;;; Commentary:

;; Emacs backend for dropbox.
;;
;; 1. Download `dropbox.el` and load it (with `load` or `require`)
;; 2. The first time, you should generate the config file with `M-x dropbox-gen-config`
;;    (You can reuse the one generated by `dropbox_uploader.sh`, compatible)
;; 3. Then use `dropbox-find` to search and pick file,
;;    Use `C-x C-f /db:` or `C-x C-f /db:/PATH-ON-DROPBOX` to open file
;;

;;; Code:

(require 'json)
(require 'cl-lib)
(require 'url-http)

(eval-when-compile
  (defvar url-http-end-of-headers)
  (defvar url-http-response-status))

(defgroup dropbox nil
  "Dropbox on Emacs."
  :prefix "dropbox-"
  :group 'applications)

(defcustom dropbox-debug nil
  "Toggle debug output."
  :type 'boolean)

(defcustom dropbox-config-file "~/.dropbox"
  "Use the config file generated by dropbox.shell."
  :type 'string)

(defvar dropbox-prefix "/db:")

(defvar dropbox-config nil)


;;; Utility

(defun dropbox-info (fmt-string &rest args)
  "Used to output debug info."
  (when dropbox-debug
    (apply #'message (concat "\t[Dropbox] " fmt-string) args)))

(defun dropbox-normalize (path &optional force-prefix-p)
  "Normalize PATH to the right format."
  (when path
    (when (string-match-p "/$" path)
      (setq path (substring path 0 -1)))
    (when (string-match-p (concat "^" dropbox-prefix) path)
      (setq path (substring path (length dropbox-prefix)))))
  (concat (if force-prefix-p dropbox-prefix) path))

(defun dropbox-file-p (filename)
  (string-prefix-p dropbox-prefix filename))

(defun dropbox-encode-coding-string (raw-text)
  (let ((tmp (make-temp-file "dropbox-download-")))
    (unwind-protect
        (progn (with-temp-file tmp
                 (setq buffer-file-coding-system 'raw-text)
                 (insert raw-text))
               (with-temp-buffer
                 (insert-file-contents tmp)
                 (buffer-string)))
      (delete-file tmp))))

(defvar-local dropbox--files nil)
(defvar-local dropbox--buffer-stat nil)

(defun dropbox--find-cached (name)
  "Find item from `dropbox--files', NAME should be path or name."
  (let* ((key (if (string-match-p "/" name) 'path_display 'name))
         (pos (cl-position-if (lambda (f) (string= (alist-get key f) name)) dropbox--files)))
    (if pos (cons pos (nth pos dropbox--files)))))


;;; Request

(defconst dropbox--apis
  '((token        . ("https://%s:%s@api.dropbox.com/oauth2/token"             "POST" json-read))
    (account      . ("https://api.dropboxapi.com/2/users/get_current_account" "POST" json-read))
    (usage        . ("https://api.dropboxapi.com/2/users/get_space_usage"     "POST" json-read))
    (list         . ("https://api.dropboxapi.com/2/files/list_folder"         "POST" json-read "application/json"))
    (search       . ("https://api.dropboxapi.com/2/files/search"              "POST" json-read "application/json"))
    (metadata     . ("https://api.dropboxapi.com/2/files/get_metadata"        "POST" json-read "application/json"))
    (mkdir        . ("https://api.dropboxapi.com/2/files/create_folder_v2"    "POST" json-read "application/json"))
    (delete       . ("https://api.dropboxapi.com/2/files/delete_v2"           "POST" json-read "application/json"))
    (move         . ("https://api.dropboxapi.com/2/files/move_v2"             "POST" json-read "application/json"))
    (copy         . ("https://api.dropboxapi.com/2/files/copy_v2"             "POST" json-read "application/json"))
    (upload       . ("https://content.dropboxapi.com/2/files/upload"          "POST" json-read "application/octet-stream"))
    (download     . ("https://content.dropboxapi.com/2/files/download"        "GET"  buffer-string))
    (download-zip . ("https://content.dropboxapi.com/2/files/download_zip"    "GET"  buffer-string))))

(cl-defmacro with-dropbox-response ((var parser) &body body)
  (declare (indent 1))
  `(unwind-protect
       (if (not url-http-response-status)
           (user-error "Broken request? -- %s" (buffer-string))
         (if (< 199 url-http-response-status 300)
             (let ((,var (progn
                           (set-buffer-multibyte t)
                           (narrow-to-region (+ 1 url-http-end-of-headers) (point-max))
                           (goto-char (point-min))
                           (funcall ,parser))))
               ,@body)
           (signal 'user-error
                   (list url-http-response-status
                         (string-trim (buffer-substring url-http-end-of-headers (point-max)))))))
     (kill-buffer)))

(cl-defun dropbox-make-request (func &key data headers api-arg done sync)
  (pcase-let* ((`(,url ,method ,parser ,content-type) (alist-get func dropbox--apis)))
    ;; Headers
    (if content-type (push `("Content-Type" . ,content-type) headers))
    ;; Encode
    (when (and content-type (string-match-p "json" content-type))
      (if api-arg (setq api-arg (json-encode api-arg)))
      (if data (setq data (json-encode data))))
    ;; Auth
    (if (string-match-p "%s:%s@" url)
        (let* ((config (dropbox-get-config))
               (key (alist-get :app_key config))
               (sec (alist-get :app_secret config)))
          (setq url (format url key sec)))
      (push `("Authorization" . ,(concat "Bearer " (dropbox-get-token))) headers))
    ;; Args
    (when api-arg
      (push `("Dropbox-API-Arg" . ,(encode-coding-string api-arg 'utf-8)) headers))
    (let ((url-request-method method)
          (url-request-data (if data (encode-coding-string data 'utf-8) data))
          (url-request-extra-headers headers))
      (dropbox-info "`%s' request with headers: %s" func headers)
      (dropbox-info "`%s' request with data: %s" func url-request-data)
      (cond (sync ; sync | async
             (let ((buf (url-retrieve-synchronously url t t)))
               (when (buffer-live-p buf)
                 (with-current-buffer buf
                   (with-dropbox-response (result parser)
                     (dropbox-info "`%s' sync response successful: %s" func result)
                     result)))))
            (t (url-retrieve url (lambda (_status buf bufstat)
                                   (with-dropbox-response (res parser)
                                     (dropbox-info "`%s' response successful: %s" func res)
                                     (when (buffer-live-p buf)
                                       ;; use `dropbox--buffer-stat' to check whether current callback is valid
                                       ;; when current [dired] buffer is killed or refreshed, then it's invalid
                                       ;; then do nothing: drop and return
                                       ;; maybe this also can be done by advicing `process-filter'
                                       (let ((nowstat (with-current-buffer buf dropbox--buffer-stat)))
                                         (when (equal nowstat bufstat)
                                           (with-current-buffer buf (funcall done res)))))))
                             `(,(current-buffer) ,dropbox--buffer-stat) t t))))))


;;; Authorization

;;;###autoload
(defun dropbox-gen-config ()
  "Generate the config file containing auth infomation."
  (interactive)
  (if (file-exists-p dropbox-config-file)
      (user-error "Config file '%s' exists, delete it or give up" dropbox-config-file)
    (let* ((app-url "https://www.dropbox.com/developers/apps")
           (auth-url "https://www.dropbox.com/oauth2/authorize?client_id=%s&token_access_type=offline&response_type=code")
           (help (format "\nThis is the first time you run this, please follow the instructions:\n
 1) Open '%s' in your Browser, and log in
 2) Click on 'Create App', then switch to tab 'permissions' and check 'files.metadata.read/write' and 'files.content.read/write'
 3) To tab 'settings' and you will see the 'appkey' and 'appsec' needed later.\n
Ready and go?" app-url)))
      (when (y-or-n-p help)
        (let ((key (read-string "App key: "))
              (sec (read-string "App secret: ")))
          (when (y-or-n-p (format "\napp_key:\t%s\napp_secret:\t%s\n\nIf nothing wrong, press y to generate 'access-code' from page, then back to continue" key sec))
            (browse-url (format auth-url key))
            (unwind-protect
                (progn
                  (setq dropbox-config `((:app_key . ,key) (:app_secret . ,sec)))
                  (let* ((access-code (read-string "Access code you get from page: "))
                         (refresh-token (dropbox-get-refresh-token access-code))
                         (content (format "CONFIGFILE_VERSION=2.0\nOAUTH_APP_KEY=%s\nOAUTH_APP_SECRET=%s\nOAUTH_REFRESH_TOKEN=%s"
                                          key sec refresh-token)))
                    (with-temp-file dropbox-config-file (insert content))
                    (message "File `%s` generated done!" dropbox-config-file)))
              (setq dropbox-config nil))))))))

(defun dropbox-load-config ()
  (if (file-exists-p dropbox-config-file)
      (with-temp-buffer
        (insert-file-contents dropbox-config-file)
        (cl-loop for line in (split-string (buffer-string) "\n")
                 if (string-match-p "=" line)
                 collect (let* ((linepair (split-string line "="))
                                (key (intern (concat ":" (replace-regexp-in-string "oauth_" "" (downcase (car linepair))))))
                                (value (cadr linepair)))
                           (cons key value ))
                 into fs finally return
                 (if (alist-get :refresh_token fs) fs
                   (user-error "Load config file '%s' failed, please check and regenerate" dropbox-config-file))))
    (user-error "No '%s' found, please execute `dropbox-gen-config' command to generate one" dropbox-config-file)))

(defun dropbox-get-config (&optional force)
  (or (unless force dropbox-config)
      (setq dropbox-config (dropbox-load-config))))

(defun dropbox-get-refresh-token (&optional access-code)
  "If ACCESS-CODE is not null, request from server, else return locally."
  (if access-code
      (alist-get 'refresh_token
                 (dropbox-make-request 'token
                                       :data (concat "grant_type=authorization_code&code=" access-code)
                                       :sync t))
    (alist-get :refresh_token (dropbox-get-config))))

(defun dropbox-get-token (&optional callback)
  "When available, return. when CALLBACK is absent, do it syncronized."
  (let* ((config (dropbox-get-config))
         (expired (alist-get :expired config))
         (token (alist-get :access_token config))
         (avail (and token expired (time-less-p (current-time) expired))))
    (cond
     ((and avail (null callback)) token)
     ((and avail callback) (funcall callback token))
     (t (message "[dropbox] Getting token...")
        (cl-labels ((save (result)
                      (let* ((tk (alist-get 'access_token result))
                             (etime (time-add (current-time) (seconds-to-time (- (alist-get 'expires_in result) 120)))))
                        (setf (alist-get :access_token dropbox-config) tk)
                        (setf (alist-get :expired dropbox-config) etime))))
          (let ((r (dropbox-make-request 'token
                                         :data (concat "grant_type=refresh_token&refresh_token=" (dropbox-get-refresh-token))
                                         :done (lambda (result)
                                                 (save result)
                                                 (funcall callback (alist-get :access_token dropbox-config)))
                                         :sync (not callback))))
            (when (and (not callback) r)
              (save r)
              (alist-get :access_token dropbox-config))))))))

(defun dropbox-short-lived-access-token (&optional appkey)
  "Add `https://www.dropbox.com/1/oauth2/display_token' to redirect-urls first."
  (interactive)
  (unless appkey
    (let* ((key (ignore-errors (alist-get :app_key (dropbox-get-config))))
           (prompt (concat "app-key" (if key (format " (%s)" key)) ": ")))
      (setq appkey (read-string prompt nil nil key))))
  (browse-url
   (format "https://www.dropbox.com/oauth2/authorize?response_type=token&redirect_uri=%s&client_id=%s"
           "https://www.dropbox.com/1/oauth2/display_token" appkey)))


;;; API

(cl-defgeneric dropbox-req (api-key &rest path-callback-and-others))

(cl-defmethod dropbox-req :around (func &rest args)
  (let ((async? (cl-find-if #'functionp args)))
    ;; Debug info
    (dropbox-info "calling for `%s'%s..." func (if async? "" " syncronized"))
    ;; Some params should be normalized
    (cond ((memq func '(list metadata mkdir delete download))
           (setf (car args) (dropbox-normalize (car args))))
          ((memq func '(move copy upload))
           (setf (car args) (dropbox-normalize (car args)))
           (setf (cadr args) (dropbox-normalize (cadr args)))))
    ;; Make sure the access-token is alive
    (if async?
        (dropbox-get-token (lambda (_) (apply #'cl-call-next-method func args)))
      (dropbox-get-token)
      (apply #'cl-call-next-method func args))))

(cl-defmethod dropbox-req ((_ (eql 'account)) &optional callback)
  (dropbox-make-request 'account :done callback :sync (not callback)))

(cl-defmethod dropbox-req ((_ (eql 'usage)) callback)
  (dropbox-make-request 'usage :done callback))

(cl-defmethod dropbox-req ((_ (eql 'list)) path callback)
  (dropbox-make-request 'list
                        :data `(("path" . ,path)
                                ("recursive" . :json-false)
                                ("include_media_info" . :json-false)
                                ("include_deleted" . :json-false)
                                ("include_has_explicit_shared_members" . :json-false)
                                ("include_mounted_folders" . t))
                        :done callback))

(cl-defmethod dropbox-req ((_ (eql 'search)) text &optional path callback)
  "Search files on Dropbox under PATH and containing TEXT."
  (dropbox-make-request 'search
                        :data `(("query" . ,text)
                                ("path"  . ,(or path ""))
                                ("start" . 0)
                                ("max_results" . 1000)
                                ("mode"  . "filename"))
                        :done callback
                        :sync (not callback)))

(cl-defmethod dropbox-req ((_ (eql 'metadata)) path &optional callback)
  "When CALLBACK is absent, request syncronized."
  (let ((empty '((name . "")
                 (\.tag . "folder")
                 (path_lower . "")
                 (path_display . ""))))
    (if (string= path "")
        (if callback (funcall callback empty) empty)
      (dropbox-make-request 'metadata
                            :data `(("path" . ,path)
                                    ("include_media_info" . :json-false)
                                    ("include_deleted" . :json-false)
                                    ("include_has_explicit_shared_members" . :json-false))
                            :done callback
                            :sync (not callback)))))

(cl-defmethod dropbox-req ((_ (eql 'mkdir)) path)
  "Make dir syncronized."
  (dropbox-make-request 'mkdir
                        :data `(("path" . ,path)
                                ("autorename" . :json-false))
                        :sync t))

(cl-defmethod dropbox-req ((_ (eql 'delete)) file)
  "Delete FILE syncronized."
  (dropbox-make-request 'delete
                        :data `(("path" . ,file))
                        :sync t))

(cl-defmethod dropbox-req ((_ (eql 'move)) from to callback)
  (dropbox-make-request 'move
                        :data `(("from_path" . ,from) ("to_path" . ,to))
                        :done callback))

(cl-defmethod dropbox-req ((_ (eql 'copy)) from to callback)
  (dropbox-make-request 'copy
                        :data `(("from_path" . ,from) ("to_path" . ,to))
                        :done callback))

(cl-defmethod dropbox-req ((_ (eql 'upload)) local remote &optional overwrite)
  "Upload file syncronized."
  (dropbox-make-request 'upload
                        :data (with-temp-buffer
                                (insert-file-contents-literally local)
                                (buffer-string))
                        :api-arg (json-encode `(("path" . ,remote)
                                                ("mode" . ,(if overwrite "overwrite" "add"))
                                                ("autorename" . t)
                                                ("mute" . :json-false)
                                                ("strict_conflict" . :json-false)))
                        :sync t))

(cl-defmethod dropbox-req ((_ (eql 'download)) path &optional callback zip?)
  "If PATH is a dictionay and ZIP? is t, then download zip."
  (when (and zip? (not (file-directory-p (dropbox-normalize path t))))
    (user-error "Download to .zip is used for dictionay"))
  (dropbox-make-request (if zip? 'download-zip 'download)
                        :api-arg (json-encode `(("path" . ,path)))
                        :done callback
                        :sync (not callback)))

;; (dropbox-get-token #'dropbox--ignore)
;; (dropbox-req 'account #'dropbox--ignore)
;; (dropbox-req 'list "" #'dropbox--ignore)
;; (dropbox-req 'search "p")
;; (dropbox-req 'metadata "/vvv" #'dropbox--ignore)
;; (dropbox-req 'metadata "/" #'dropbox--ignore)
;; (dropbox-req 'metadata "/vvv")
;; (dropbox-req 'usage #'dropbox--ignore)
;; (dropbox-req 'mkdir "/vvv/c2cc")
;; (dropbox-req 'delete "/vvv/c2cc")
;; (dropbox-req 'move "/vvv/bashrc.txt" "/vvv/bashrc-2.txt" #'dropbox--ignore)
;; (dropbox-req 'copy "/vvv/bashrc-2.txt" "/vvv/bashrc-4.txt" #'dropbox--ignore)
;; (dropbox-req 'upload "/home/vip/.bashrc" "/vvv/bashrc.txt")
;; (dropbox-req 'download "/vvv/persons.json" #'dropbox--ignore)
;; (dropbox-req 'download "/vvv/persons.json")
;; (dropbox-req 'download "/vvv" nil t)

(defun dropbox--ignore (&optional x) (if x (message "-=≕---> %s" x)))


;;; Handler

(defun dropbox-handler (operation &rest args)
  (let ((handler (intern (format "dropbox-handle:%s" operation))))
    (if (fboundp handler)
        (apply handler args)
      (dropbox-run-real-handler operation args))))

(defun dropbox-run-real-handler (operation args)
  (let* ((inhibit-file-name-handlers `(dropbox-handler
                                       tramp-file-name-handler
                                       tramp-vc-file-name-handler
                                       tramp-completion-file-name-handler
                                       . ,inhibit-file-name-handlers))
         (inhibit-file-name-operation operation))
    (apply operation args)))

(defun dropbox-handle:file-exists-p (filename)
  (dropbox-info "[handler] file-exists-p: %s" filename)
  (setq filename (dropbox-normalize filename))
  ;; patch for some special cases, for performance
  (cond ((string-match-p "^/?$" filename) t)
        ((string-match-p "~/" filename) nil)
        ((string-match-p "[/.]tags$" filename) nil) ; citre
        (t (ignore-errors
             (or (alist-get 'metadata (cdr (dropbox--find-cached filename)))
                 (dropbox-req 'metadata filename))))))

(defun dropbox-handle:file-readable-p (filename)
  (cond ((string-match-p "\\.editorconfig" filename) nil) ; boring editorconfig! disable hardcode
        (t t)))

(defun dropbox-handle:file-directory-p (filename)
  (dropbox-info "[handler] file-directory-p: %s" filename)
  (let* ((filename (dropbox-normalize filename))
         (metadata (or (alist-get 'metadata (cdr (dropbox--find-cached filename)))
                       (condition-case err
                           (dropbox-req 'metadata filename)
                         (user-error (unless (equal (cadr err) 409)
                                       (user-error "%s" (cadr err))))))))
    (string= (alist-get '\.tag metadata) "folder")))

(defun dropbox-handle:file-executable-p (filename)
  (file-directory-p filename))

(defun dropbox-handle:file-regular-p (file)
  (not (file-directory-p file)))

(defun dropbox-handle:file-remote-p (file &optional identification _connected)
  (cl-case identification
    ((method) dropbox-prefix)
    ((user) "")
    ((host) "")
    ((localname) (dropbox-normalize file))
    (t (concat dropbox-prefix "/"))))

(defun dropbox-handle:expand-file-name (name &optional dir)
  (if (string-prefix-p dropbox-prefix name) name
    (dropbox-run-real-handler #'expand-file-name (list name dir))))

(defun dropbox-handle:file-name-directory (filename)
  (if (string-match (concat "^\\(" dropbox-prefix ".*/\\).*$") filename)
      (match-string 1 filename)
    dropbox-prefix))

(defun dropbox-handle:file-name-nondirectory (filename)
  (if (string-match (concat "^" dropbox-prefix ".*/\\(.*\\)$") filename)
      (match-string 1 filename)
    (substring filename 4)))

;; CRUD

(defun dropbox-handle:make-directory (dir &optional _parents)
  (setq dir (dropbox-normalize dir))
  (dropbox-req 'mkdir dir)
  (message "Mkdir %s Done!" dir))

(defun dropbox-handle:delete-file (filename &optional _trash)
  (setq filename (dropbox-normalize filename))
  (dropbox-req 'delete filename)
  (message "Delete %s done!" filename))

(defun dropbox-handle:delete-directory (directory &optional _recursive _trash)
  (setq directory (dropbox-normalize directory))
  (dropbox-handle:delete-file directory))

(defun dropbox-handle:copy-file (file newname &optional _ok-if-already-exists _keep-time _preserve-uid-gid _preserve-selinux-context)
  (cond
   ((and (dropbox-file-p file) (dropbox-file-p newname))
    (dropbox-req 'copy
                 (dropbox-normalize file)
                 (dropbox-normalize newname)
                 (lambda (_) (message "Copy done."))))
   ((and (dropbox-file-p file) (not (dropbox-file-p newname)))
    (rename-file (file-local-copy file) newname))
   ((and (not (dropbox-file-p file)) (dropbox-file-p newname))
    (dropbox-req 'upload file newname))))

(defun dropbox-handle:copy-directory (directory newname &optional keep-time parents copy-contents)
  (cond
   ((and (dropbox-file-p directory) (dropbox-file-p newname))
    (if parents (make-directory
                 (file-name-directory (directory-file-name newname))
                 parents))
    (copy-file directory newname nil keep-time parents copy-contents))
   ((and (dropbox-file-p directory) (string-match-p "\\.zip$" newname))
    (let ((content (dropbox-req 'download directory nil t)))
      (with-temp-file newname (insert content))))
   (t (error "Copying directory from local to remote is not supported"))))

(defun dropbox-handle:rename-file (file newname &optional ok-if-already-exists)
  (cond
   ((and (dropbox-file-p file) (dropbox-file-p newname))
    (dropbox-req 'move
                 (dropbox-normalize file)
                 (dropbox-normalize newname)
                 (lambda (_) (message "Done.")))
    ;; too many writes error? so wait...
    (sleep-for 1))
   ((and (dropbox-file-p file) (not (dropbox-file-p newname)))
    (copy-file file newname ok-if-already-exists)
    (delete-file file t))
   ((and (not (dropbox-file-p file)) (dropbox-file-p newname))
    (copy-file file newname ok-if-already-exists)
    (delete-file file t))))

;; Contents

(defun dropbox--set-cached (path key value)
  (let ((idx (car (dropbox--find-cached path))))
    (push (cons key value) (nth idx dropbox--files))))

(defun dropbox--set-progress ()
  (let* ((metas (cl-remove-if-not (lambda (f) (alist-get 'rendered f)) dropbox--files))
         (finished (or (null dropbox--files) (= (length dropbox--files) (length metas)))))
    (save-excursion
      (goto-char (point-min))
      (re-search-forward "used)" nil t)
      (with-silent-modifications
        (delete-region (point) (line-end-position))
        (insert (if finished ", loaded success."
                  (format ", loading %s/%s" (length metas) (length dropbox--files))))
        (cond ((null dropbox--files) (message "Done with nothing found."))
              (finished (message "Done.")))))))

(defun dropbox-handle:file-modes (&rest _) 492)

(defun dropbox-handle:file-attributes (filename &optional _id-format ometadata)
  (setq filename (dropbox-normalize filename))
  (let* ((meta (or ometadata
                   (when-let* ((file (dropbox--find-cached filename)))
                     (alist-get 'metadata file))))
         (date (date-to-time (or (alist-get 'client_modified meta) "Mon, 01 Jan 0000 00:00:00 +0000")))
         (folder (if meta (string= "folder" (alist-get '.tag meta)) (file-directory-p filename)))
         (size (if meta (alist-get 'size meta)))
         (perm (concat (if folder "d" "-") "rwxr-xr--")))
    ;; folder? / links / UID / GID / atime / mtime / ctime / size / perm
    (list folder 1 0 0 date date date (or size 0) perm t nil nil)))

(defun dropbox-handle:insert-directory (filename _switches &optional _wildcard full-directory-p)
  "Async, so make `directory-files' return nil, and loading here."
  (dropbox-info "[handler] insert-directory: %s" filename)
  (setq filename (expand-file-name filename))
  (setq-local dropbox--buffer-stat (cl-gensym "dropbox--buffer-stat->"))

  (cl-labels ((create-row (name metadata)
                (let* ((attrs (dropbox-handle:file-attributes name nil metadata))
                       (a (format "  %s %2d %2s %2s %8s %s "
                                  (elt attrs 8) (elt attrs 1) (elt attrs 2) (elt attrs 3)
                                  (file-size-human-readable (elt attrs 7))
                                  (format-time-string "%Y-%m-%d %H:%M" (elt attrs 4))))
                       (s (with-temp-buffer
                            (insert name "\n")
                            (put-text-property (point-min) (- (point-max) 1) 'dired-filename t)
                            (buffer-string))))
                  (goto-char (point-max))
                  (with-silent-modifications
                    (insert a) (save-excursion (insert s)))
                  (redraw-display))))

    (if (not full-directory-p)
        (dropbox-req 'metadata filename
          (lambda (metadata)
            (create-row (alist-get 'name metadata) metadata)))

      (dropbox-req 'usage
        (lambda (usage)
          (message "Loading...")
          (let ((used (alist-get 'used usage))
                (allocated (alist-get 'allocated (alist-get 'allocation usage))))
            (with-silent-modifications
              (goto-char (point-max))
              (insert (format "  dropbox: total %s, available %s (%.0f%% used)\n"
                              (file-size-human-readable allocated)
                              (file-size-human-readable (- allocated used))
                              (/ (* used 100.0) allocated)))))

          (dropbox-req 'list filename
            (lambda (entries)
              (setq dropbox--files (cl-coerce (alist-get 'entries entries) 'list))
              (if dropbox--files
                  (dolist (entry dropbox--files)
                    (let ((path (alist-get 'path_display entry)))

                      (dropbox-req 'metadata path
                        (lambda (md)
                          (dropbox--set-cached path 'metadata md)
                          (cl-loop for file in dropbox--files
                                   unless (alist-get 'rendered file)
                                   unless (alist-get 'metadata file) return t
                                   else do (save-excursion
                                             (create-row (alist-get 'name file) (alist-get 'metadata file))
                                             (dropbox--set-cached (alist-get 'path_display file) 'rendered t)
                                             (dropbox--set-progress)))))))
                (dropbox--set-progress)))))))))

(defun dropbox-handle:insert-file-contents (filename &optional visit _beg _end replace)
  (dropbox-info "[handler] insert-file-contents: %s" filename)
  (condition-case err
      (let (count)
        (when (file-exists-p filename)
          (let ((s (dropbox-encode-coding-string (dropbox-req 'download filename))))
            (if replace (erase-buffer))
            (setq count (length s))
            (save-excursion (insert s))))
        (when visit
          (setf buffer-file-name filename)
          (setf buffer-read-only (not (file-writable-p filename)))
          (set-visited-file-modtime (current-time))) ; assume that no concurrent edit
        (cons filename count))
    (error (kill-buffer) (signal 'user-error (cdr err)))))

(defun dropbox-handle:write-region (beg end filename &optional append visit _lockname _mustbenew)
  (dropbox-info "[handler] write-region: %s, %s, %s" filename beg end)
  (cl-assert (not append))
  (let* ((tmpfile (make-temp-file (file-name-nondirectory filename))))
    (unwind-protect
        (let (create-lockfiles)
          (write-region beg end tmpfile nil 'no-message)
          (dropbox-req 'upload tmpfile filename t))
      (delete-file tmpfile))
    (when (stringp visit)
      (set-visited-file-name visit))
    (when (or (eq t visit) (stringp visit))
      (set-buffer-modified-p nil))
    (when (or (eq t visit) (eq nil visit) (stringp visit))
      (message "Wrote %s" filename))
    (setq save-buffer-coding-system buffer-file-coding-system)))

(defun dropbox-handle:file-local-copy (filename)
  (dropbox-info "[handler] file-local-copy: %s" filename)
  (if (not (file-exists-p filename))
      (error "File to copy doesn't exist")
    (save-excursion
      (let* ((newname (make-temp-file (file-name-nondirectory filename) nil
                                      (concat "." (file-name-extension filename)))))
        (with-temp-file newname
          (set-buffer-file-coding-system 'raw-text)
          (insert-file-contents-literally filename))
        newname))))

(defun dropbox-handle:dired-insert-directory (dir switches &optional file-list wildcard _hdr)
  (dropbox-info "[handler] dired-insert-directory: %s" dir)
  (if file-list
      (cl-loop for file in file-list
               do (insert-directory (concat dir file) switches))
    (insert-directory dir switches wildcard t)))

(defun dropbox-handle:load (file &optional noerror nomessage nosuffix must-suffix)
  "Load a remote FILE."
  (let (localfile)
    (condition-case nil
        (setq localfile (file-local-copy file))
      (error (user-error "File %s not found" file)))
    (when (and localfile (file-exists-p localfile))
      (let ((signal-hook-function (unless noerror signal-hook-function))
	        (inhibit-message (or inhibit-message nomessage)))
        (unwind-protect
            (load localfile noerror t nosuffix must-suffix))
        (delete-file localfile)))))

;; Rude handling

(defun dropbox-handle:file-writable-p (_) t)
(defun dropbox-handle:file-owner-preserved-p (_) t)
(defun dropbox-handle:directory-files (&rest _) nil)
(defun dropbox-handle:make-symbolic-link (&rest _) nil)
(defun dropbox-handle:add-name-to-file (&rest _) nil)
(defun dropbox-handle:dired-compress-file (&rest _) nil)
(defun dropbox-handle:find-backup-file-name (&rest _) nil)
(defun dropbox-handle:unhandled-file-name-directory (&rest _) nil)
(defun dropbox-handle:start-file-process (&rest _) nil)
(defun dropbox-handle:process-file (&rest _) nil)
(defun dropbox-handle:shell-command (&rest _) nil)
(defun dropbox-handle:executable-find (_) nil)
(defun dropbox-handle:vc-registered (&rest _) nil)
(defun dropbox-handle:set-file-modes (&rest _) nil)
(defun dropbox-handle:set-file-times (&rest _) nil)
(defun dropbox-handle:set-visited-file-modtime (&rest _) nil)
(defun dropbox-handle:verify-visited-file-modtime (&optional _buf) t)
(defun dropbox-handle:file-selinux-context (&rest _) nil)


;;; Patches

(declare-function project--find-in-directory "ext:project.el" t t)

(defun dropbox-project--find-in-directory-advice (fn dir)
  "Tell directly which is the project root."
  (if (dropbox-file-p dir)
      (cons 'transient dropbox-prefix)
    (funcall fn dir)))

(advice-add #'project--find-in-directory :around #'dropbox-project--find-in-directory-advice)



;;;###autoload
(defun dropbox-find (&optional choose-dir)
  "Search files from Dropbox and open it.
It will search all files, with a prefix CHOOSE-DIR
will allow you specify a dir to search."
  (interactive "P")
  (let ((input (read-string "Search Dropbox with: ")))
    (when (< (length (replace-regexp-in-string " " "" input)) 1)
      (user-error "Maybe input is too short"))
    (let* ((dir (when choose-dir
                  (let* ((def (if (dropbox-file-p default-directory) (dropbox-normalize default-directory)))
                         (sel (read-string "Searching in directory: " def)))
                    (cond ((or (null sel) (string= sel "/") (string= sel "")) nil)
                          (t (if (string-prefix-p "/" sel) sel (concat "/" sel)))))))
           (desc (if dir (concat " in '" dir "'") ""))
           (prompt (format "Dropbox files%s (matching %s): " desc input)))
      (message "Searching%s..." desc)
      (let* ((files (dropbox-req 'search input dir))
             (candicates (cl-loop
                          for file across (alist-get 'matches files)
                          for metadata = (alist-get 'metadata file)
                          when (string= (alist-get '.tag metadata) "file")
                          collect (dropbox-normalize (alist-get 'path_display metadata) t))))
        (when (< (length candicates) 1)
          (user-error "Nothing found on Dropbox%s with '%s'" desc input))
        (let ((f (completing-read prompt candicates)))
          (if (dropbox-file-p f)
              (find-file f)
            (user-error "Are you taking an odd file '%s' as a dropbox file?" f)))))))

;;;###autoload
(defun dropbox-browser (&optional dir)
  "Open current directory or DIR in your browser."
  (interactive)
  (let* ((home "https://www.dropbox.com/home")
         (dir (or dir (if (dropbox-file-p default-directory) (dropbox-normalize default-directory))))
         (path (read-string "Directory open in browser: " dir)))
    (unless (string-prefix-p "/" path)
      (user-error "Maybe you input a invalid path"))
    (browse-url (concat home path))))

(add-to-list 'file-name-handler-alist
             `(,(concat "\\`" dropbox-prefix) . dropbox-handler))

(provide 'dropbox)

;;; dropbox.el ends here
